@import play.routes.compiler._
@import play.routes.compiler.templates._
@import InjectedRoutesGenerator.Dependency

@(sourceInfo: RoutesSourceInfo, pkg: Option[String], imports: Seq[String],
  deps: Seq[Dependency[Rule]], pathRules: Seq[(String, Seq[Dependency[Rule]])], includes: Seq[Dependency[Include]])
// @@GENERATOR:play-routes-compiler
// @@SOURCE:@sourceInfo.source

@for(p <- pkg) {package @p}

import play.core.routing._

import play.api.mvc._
@for(i <- imports) {
import @if(!i.startsWith("_root_.")){_root_.}@i}

final class Routes(
  override val errorHandler: play.api.http.HttpErrorHandler, @for(dep <- deps){
  @markLines(dep.rule)
  @dep.ident: @dep.clazz,}
) extends GeneratedRouter @ob

  final val prefix: String = "/"
  def withPrefix(addPrefix: String): Routes = ???

@for((rules, pathIndex) <- pathRules.map(_._2).zipWithIndex){
@for((dep, index) <- rules.zipWithIndex){@dep.rule match {
case route @ Route(verb, path, call, comments, modifiers) => {
  @markLines(route)
  private val @routeIdentifier(route, pathIndex, index) = Route("@verb.value",
    PathPattern(List(@path.parts.map(_.toString).mkString(", ")))
  )
}
case include @ Include(path, router) => {
  @markLines(include)
  private val prefixed_@(dep.ident)_@(pathIndex * 1000 + index) = Include(@(dep.ident))
}}}}

  val pathRouters: Map[String, PartialFunction[RequestHeader, Handler]] = Map(
    @for(((path, rules), pathIndex) <- pathRules.zipWithIndex) {
      "@path" -> @ob
        @for((dep, index) <- rules.zipWithIndex){@dep.rule match {
        case include: Include => {
          @markLines(include)
          case prefixed_@(dep.ident)_@(pathIndex * 1000 + index)(handler) => handler
        }
        case route: Route => {
          @markLines(route)
          case @(routeIdentifier(route, pathIndex, index))(params@@_) =>
            named("@(route.call.controller).@(route.call.method)") @ob
              call@(routeBinding(route)) @ob @localNames(route)
                  @injectedControllerMethodCall(route, dep.ident, x => safeKeyword(x.nameClean))
              @cb
            @cb
        }
        }}
      @cb,
    }
  )

  val routes: PartialFunction[RequestHeader, Handler] =
    @if(pathRules.isEmpty) { Map.empty } else {@ob
      val emptyPathRouter = pathRouters get ""
      Function unlift @ob (req: RequestHeader) =>
        pathRouters.get(req.path.drop(1).takeWhile(_ != '/')).orElse(emptyPathRouter).flatMap(_ lift req)
      @cb
    @cb}
@cb
